/*
 * Copyright 2012, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


import java.text.SimpleDateFormat

sourceCompatibility = "1.8"

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath depends.proguard_gradle
    }
}

sourceSets {
    integrationTest {
        java {
            compileClasspath += main.output + test.output
            runtimeClasspath += main.output + test.output
//            srcDir file('src/integration-test/java')
        }
//        resources.srcDir file('src/integration-test/resources')
    }
}

configurations {
    integrationTestCompile.extendsFrom testCompile
    integrationTestRuntime.extendsFrom testRuntime
}

dependencies {
    compile project(':util')
    compile project(':dexlib2')
    compile depends.commons_cli
    compile depends.guava
    compile files('lib/dx.jar')
    compile 'net.java.dev.activeobjects:activeobjects:1.1.5'
    compile 'com.google.code.gson:gson:2.7'
    
    testCompile 'net.java.dev.activeobjects:activeobjects-test:1.1.5'
    
    compile 'org.slf4j:slf4j-simple:1.7.14'
    compile 'org.hsqldb:hsqldb:2.3.3'
    
    compile group: 'org.apache.logging.log4j', name: 'log4j-api', version: '2.5'
    compile group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.5'
    
    testCompile depends.junit
    testCompile project(':smali')
    testCompile "org.mockito:mockito-core:1.10.19"
}

processResources.inputs.property('version', version)
processResources.expand('version': version)

// This is the jar that gets uploaded to maven
jar {
    baseName = 'maven'
}

// Build a separate jar that contains all dependencies
task fatJar(type: Jar) {
    from sourceSets.main.output
    from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }

    manifest {
        attributes('Main-Class': 'astli.main.main')
    }

    doLast {
        if (!System.getProperty('os.name').toLowerCase().contains('windows')) {
            ant.symlink(link: file("${destinationDir}/astli.jar"), resource: archivePath, overwrite: true)
        }
    }
}
tasks.getByPath('build').dependsOn(fatJar)

task proguard(type: proguard.gradle.ProGuardTask, dependsOn: fatJar) {
    def outFile = fatJar.destinationDir.getPath() + '/' + fatJar.baseName + '-' + fatJar.version + '-small' + '.' + fatJar.extension

    injars fatJar.archivePath
    outjars outFile

    libraryjars "${System.properties['java.home']}/lib/rt.jar"

    dontobfuscate
    dontoptimize

    keep 'public class astli.main { public static void main(java.lang.String[]); }'
    keepclassmembers 'enum * { public static **[] values(); public static ** valueOf(java.lang.String); }'

    dontwarn 'com.google.common.**'
    dontnote 'com.google.common.**'
}

tasks.getByPath(':release').dependsOn(proguard)

task copyTestTimeLibs(type: Copy) {
    into "build/test.lib"
    from configurations.testCompile
}

if (!hasProperty('mainClass')) {
    ext.mainClass = 'astli.main'
}

allprojects {
    gradle.projectsEvaluated {
        tasks.withType(JavaCompile) {
            options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
        }
    }
}

task integrationTest(type: Test) {
    testClassesDir = sourceSets.integrationTest.output.classesDir
    classpath = sourceSets.integrationTest.runtimeClasspath
    outputs.upToDateWhen { false }
    testLogging{ showStandardStreams = true }
}

test {
    //do you need to debug an integration test in netbeans ide? 
    //-> comment out line "exclude ..."
    //side effect: when you run unit tests, integration tests will be included 
    //(takes long!)
    exclude 'astli/integration/**'
    testLogging{ showStandardStreams = true }
}

apply plugin: "jacoco"

jacocoTestReport {
    reports {
        xml.enabled false
        csv.enabled false
        html.destination "${buildDir}/jacocoHtml"
    }
    
    afterEvaluate {
        classDirectories = files(classDirectories.files.collect {
            fileTree(dir: it, exclude: 'org/jf/**')
        })
    }
}

//foss evaluate

def apkFilter = new FilenameFilter() {
    boolean accept(File path, String filename) {
        return filename.matches(".*apk\$")
    }
}

def resources = sourceSets.integrationTest.getResources().getSrcDirs()?.find{true}; 
def apksFolderPath = "$resources/fossEvaluation/apks"

def libsFolderPath = "$resources/fossEvaluation/libs"

task fossStore {}

FileTree libFiles = fileTree(dir: libsFolderPath).include("*.jar")

libFiles.each{

	def lib = it
	def libname = lib.getName()

	task "fossStore-$libname" (type: JavaExec, dependsOn: assemble) {
        classpath sourceSets.main.runtimeClasspath
		args = ["-l", libname, lib] 
        main = "astli.main.main"
    }

	fossStore.dependsOn("fossStore-$libname")
}

def getLatestFolderName() {
    def fileNames = new ArrayList()
    
    for(file in new File("$projectDir/fossEvaluation").listFiles()) {
        try {
            fileNames.add(Integer.parseInt(file.getName()))
        } catch (NumberFormatException ex) {}
    }
    
    Collections.sort(fileNames);
    
    if(fileNames.size() > 0) {
        return (fileNames.get(fileNames.size() - 1) + 1).toString()
    }
    
    return "1"
}

def algIDs = [1];

task fossEvaluate {}

new File(apksFolderPath).listFiles().each{

    def apkFolder = it
    def apkFolderName = it.getName()
    
    task "fossEvaluate-$apkFolderName" {}
    
    fossEvaluate.dependsOn("fossEvaluate-$apkFolderName")
    
    apkFolder.listFiles(apkFilter).each{

        def apkFile     = it
        def apkFileName = it.getName()
        def mappingFile = new File(it.getPath() + ".txt")
        
        algIDs.each {
            
            def algID = it
            def taskID = "$apkFolderName-$apkFileName-$algID"
            
            task "match-$taskID" (type: JavaExec, dependsOn: assemble) {
                classpath sourceSets.main.runtimeClasspath
                args = (mappingFile.exists()) ? 
                    ["-m", "-f", mappingFile, apkFile] 
                  : ["-m", apkFile]
                main = "astli.main.main"
            }

            task "saveResultOf-$taskID" (type: Copy, dependsOn: "match-$taskID") {
                def rootFolder = getLatestFolderName()
                into("fossEvaluation/$rootFolder/$apkFolderName/$apkFileName/$algID") 
                from ("log/") {
                    include "*.*"
                }
            }
            
            project.getTasksByName("fossEvaluate-$apkFolderName", false)?.find{true}.dependsOn("saveResultOf-$taskID")
        }
    } 
}
